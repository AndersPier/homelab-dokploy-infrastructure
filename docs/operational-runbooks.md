# Operational Runbooks\n\n## Table of Contents\n\n1. [Daily Operations](#daily-operations)\n2. [Weekly Maintenance](#weekly-maintenance)\n3. [Monthly Tasks](#monthly-tasks)\n4. [Emergency Procedures](#emergency-procedures)\n5. [Backup and Recovery](#backup-and-recovery)\n6. [Performance Monitoring](#performance-monitoring)\n\n## Daily Operations\n\n### Morning Health Check (10 minutes)\n\n**Objective**: Verify all critical systems are operational\n\n**Frequency**: Every weekday at 8:00 AM\n\n**Procedure**:\n\n```bash\n#!/bin/bash\n# Daily Health Check Script - Save as /usr/local/bin/daily-health-check.sh\n\necho \"=== Homelab Daily Health Check - $(date) ===\"\n\n# 1. Check critical services\necho \"1. Checking critical services...\"\ncritical_services=(\"docker\" \"adguard-home\" \"prometheus\" \"grafana\")\nfor service in \"${critical_services[@]}\"; do\n    if systemctl is-active --quiet \"$service\" 2>/dev/null; then\n        echo \"✓ $service is running\"\n    else\n        echo \"✗ $service is not running - ALERT!\"\n    fi\ndone\n\n# 2. Check infrastructure endpoints\necho \"\\n2. Checking infrastructure endpoints...\"\nendpoints=(\n    \"https://traefik.yourdomain.com\"\n    \"https://monitoring.yourdomain.com\"\n    \"https://dev.yourdomain.com\"\n    \"https://staging.yourdomain.com\"\n    \"https://prod.yourdomain.com\"\n)\n\nfor endpoint in \"${endpoints[@]}\"; do\n    if curl -s -o /dev/null -w \"%{http_code}\" \"$endpoint\" | grep -q \"200\\|301\\|302\"; then\n        echo \"✓ $endpoint is accessible\"\n    else\n        echo \"✗ $endpoint is not accessible - ALERT!\"\n    fi\ndone\n\n# 3. Check system resources\necho \"\\n3. Checking system resources...\"\necho \"Disk Usage:\"\ndf -h | grep -E \"(Filesystem|/dev/)\" | grep -v tmpfs\n\necho \"\\nMemory Usage:\"\nfree -h\n\necho \"\\nDocker Container Status:\"\ndocker ps --format \"table {{.Names}}\\t{{.Status}}\\t{{.Ports}}\" 2>/dev/null || echo \"Docker not accessible\"\n\n# 4. Check for failed systemd services\necho \"\\n4. Checking for failed services...\"\nfailed_services=$(systemctl --failed --no-legend 2>/dev/null)\nif [ -z \"$failed_services\" ]; then\n    echo \"✓ No failed services\"\nelse\n    echo \"✗ Failed services detected:\"\n    echo \"$failed_services\"\nfi\n\n# 5. Check recent critical errors\necho \"\\n5. Recent critical errors (last hour)...\"\nerrors=$(journalctl --since \"1 hour ago\" --priority=err --no-pager -q 2>/dev/null | tail -5)\nif [ -z \"$errors\" ]; then\n    echo \"✓ No critical errors in the last hour\"\nelse\n    echo \"✗ Recent critical errors found:\"\n    echo \"$errors\"\nfi\n\necho \"\\n=== Health Check Complete - $(date) ===\"\n```\n\n**Automation**:\n```bash\n# Add to crontab\necho \"0 8 * * 1-5 /usr/local/bin/daily-health-check.sh | mail -s 'Daily Health Check' admin@yourdomain.com\" | crontab -\n```\n\n## Weekly Maintenance\n\n### Sunday Maintenance Window (1 hour)\n\n**Objective**: Perform routine maintenance and updates\n\n**Frequency**: Every Sunday at 2:00 AM\n\n**Procedure**:\n\n```bash\n#!/bin/bash\n# Weekly Maintenance Script - Save as /usr/local/bin/weekly-maintenance.sh\n\necho \"=== Weekly Maintenance - $(date) ===\"\n\n# 1. System Updates\necho \"1. Checking for system updates...\"\napt update\nupdates_available=$(apt list --upgradable 2>/dev/null | wc -l)\necho \"Available updates: $updates_available\"\n\nread -p \"Proceed with system updates? (y/N): \" -n 1 -r\necho\nif [[ $REPLY =~ ^[Yy]$ ]]; then\n    echo \"Installing updates...\"\n    apt upgrade -y\n    echo \"✓ System updates completed\"\nelse\n    echo \"⚠ System updates skipped\"\nfi\n\n# 2. Docker Maintenance\necho \"\\n2. Docker maintenance...\"\necho \"Current Docker disk usage:\"\ndocker system df\n\nread -p \"Clean up unused Docker resources? (y/N): \" -n 1 -r\necho\nif [[ $REPLY =~ ^[Yy]$ ]]; then\n    docker system prune -f\n    docker image prune -f\n    echo \"✓ Docker cleanup completed\"\nelse\n    echo \"⚠ Docker cleanup skipped\"\nfi\n\n# 3. Log Rotation\necho \"\\n3. Log management...\"\necho \"Current log disk usage:\"\ndu -sh /var/log\n\njournalctl --vacuum-time=30d\necho \"✓ System logs rotated (30 day retention)\"\n\n# 4. SSL Certificate Check\necho \"\\n4. SSL certificate status...\"\nfor domain in \"traefik.yourdomain.com\" \"dev.yourdomain.com\" \"staging.yourdomain.com\" \"prod.yourdomain.com\"; do\n    expiry=$(echo | openssl s_client -servername \"$domain\" -connect \"$domain:443\" 2>/dev/null | openssl x509 -noout -enddate 2>/dev/null | cut -d= -f2)\n    if [ -n \"$expiry\" ]; then\n        expiry_epoch=$(date -d \"$expiry\" +%s 2>/dev/null)\n        current_epoch=$(date +%s)\n        days_until_expiry=$(( (expiry_epoch - current_epoch) / 86400 ))\n        \n        if [ $days_until_expiry -gt 30 ]; then\n            echo \"✓ $domain: $days_until_expiry days until expiry\"\n        elif [ $days_until_expiry -gt 7 ]; then\n            echo \"⚠ $domain: $days_until_expiry days until expiry (monitor)\"\n        else\n            echo \"✗ $domain: $days_until_expiry days until expiry (URGENT)\"\n        fi\n    else\n        echo \"✗ $domain: Could not check certificate\"\n    fi\ndone\n\necho \"\\n=== Weekly Maintenance Complete ===\"\n```\n\n## Monthly Tasks\n\n### First Sunday of Month (2 hours)\n\n**Objective**: Comprehensive system review and planning\n\n**Procedure**:\n\n```bash\n#!/bin/bash\n# Monthly Review Script - Save as /usr/local/bin/monthly-review.sh\n\necho \"=== Monthly Infrastructure Review - $(date) ===\"\n\n# 1. Capacity Planning\necho \"1. CAPACITY PLANNING REVIEW\"\necho \"================================\"\n\necho \"Storage Usage Trends:\"\ndf -h | grep -E \"(Filesystem|/dev/)\"\n\necho \"\\nMemory Usage Analysis:\"\nfree -h\necho \"Consider upgrading if memory usage consistently >80%\"\n\necho \"\\nNetwork Usage:\"\necho \"Review bandwidth trends in Grafana: https://monitoring.yourdomain.com\"\n\n# 2. Performance Baseline\necho \"\\n2. PERFORMANCE BASELINE UPDATE\"\necho \"==============================\"\n\necho \"Current system load:\"\nuptime\n\necho \"\\nCPU performance:\"\nlscpu | grep \"CPU(s):\"\ngrep 'cpu ' /proc/stat | awk '{usage=($2+$4)*100/($2+$4+$5)} END {print \"CPU Usage: \" usage \"%\"}'\n\necho \"\\nDocker performance:\"\ndocker stats --no-stream --format \"table {{.Name}}\\t{{.CPUPerc}}\\t{{.MemUsage}}\\t{{.MemPerc}}\"\n\n# 3. Security Audit\necho \"\\n3. MONTHLY SECURITY AUDIT\"\necho \"==========================\"\n\necho \"System users review:\"\ncat /etc/passwd | grep -E \"(/bin/bash|/bin/sh)$\" | cut -d: -f1\n\necho \"\\nSudo access review:\"\ngetent group sudo\n\necho \"\\nSSH key authentication status:\"\ngrep \"PasswordAuthentication\" /etc/ssh/sshd_config\n\necho \"\\nRecent sudo usage:\"\njournalctl --since \"30 days ago\" | grep sudo | tail -10\n\n# 4. Backup Strategy Review\necho \"\\n4. BACKUP STRATEGY REVIEW\"\necho \"==========================\"\n\necho \"Backup storage usage:\"\nif [ -d \"/mnt/qnap-backup\" ]; then\n    du -sh /mnt/qnap-backup/*\n    \n    echo \"\\nBackup retention analysis:\"\n    find /mnt/qnap-backup -type f -name \"*.tar.gz\" -mtime +30 | wc -l | xargs echo \"Backups older than 30 days:\"\n    find /mnt/qnap-backup -type f -name \"*.tar.gz\" -mtime +90 | wc -l | xargs echo \"Backups older than 90 days:\"\nfi\n\necho \"\\nBackup restoration test (last performed):\"\nif [ -f \"/var/log/backup-test.log\" ]; then\n    tail -5 /var/log/backup-test.log\nelse\n    echo \"No backup restoration tests recorded\"\nfi\n\necho \"\\n=== Monthly Review Complete ===\"\necho \"\\nACTION ITEMS:\"\necho \"1. Review capacity planning and order hardware if needed\"\necho \"2. Update performance baselines in monitoring\"\necho \"3. Address any security findings\"\necho \"4. Test backup restoration procedures\"\necho \"5. Update documentation as needed\"\necho \"6. Plan next month's maintenance activities\"\necho \"7. Schedule any necessary hardware maintenance\"\n```\n\n## Emergency Procedures\n\n### Critical Service Failure\n\n#### DNS Service Down (AdGuard Home)\n\n**Immediate Response (0-5 minutes)**:\n\n```bash\n# 1. Quick diagnosis\nping 192.168.1.21  # Test AdGuard server\nnslookup google.com 192.168.1.21  # Test DNS function\n\n# 2. Attempt service restart\nsudo systemctl restart adguard-home\n\n# 3. Switch to backup DNS if restart fails\n# Update UCG Ultra DNS settings:\n# Primary: 1.1.1.1\n# Secondary: 8.8.8.8\n\n# 4. Notify stakeholders\necho \"DNS service outage - switched to backup\" | mail -s \"URGENT: DNS Outage\" admin@yourdomain.com\n```\n\n#### Infrastructure Traefik Down\n\n**Immediate Response**:\n\n```bash\n# 1. Check container status\ndocker ps | grep traefik\n\n# 2. Check logs\ndocker logs infrastructure-traefik --tail 50\n\n# 3. Restart container\ndocker restart infrastructure-traefik\n\n# 4. If restart fails, rebuild\ncd ~/homelab-infrastructure/infrastructure/traefik\ndocker-compose down\ndocker-compose up -d\n\n# 5. Verify restoration\ncurl -I https://traefik.yourdomain.com\ncurl -I https://dev.yourdomain.com\n```\n\n#### Dokploy Instance Failure\n\n**Response Procedure**:\n\n```bash\n# 1. Identify failed instance\nfor ip in 192.168.1.100 192.168.1.101 192.168.1.102; do\n    ping -c 1 $ip &>/dev/null && echo \"$ip: UP\" || echo \"$ip: DOWN\"\ndone\n\n# 2. Check service status on failed instance\nssh user@FAILED_IP \"systemctl status dokploy\"\nssh user@FAILED_IP \"docker ps\"\n\n# 3. Attempt service restart\nssh user@FAILED_IP \"sudo systemctl restart dokploy\"\n\n# 4. If VM is completely unresponsive\n# Access Proxmox: https://192.168.1.20:8006\n# Check VM console and restart if necessary\n\n# 5. Verify applications are restored\ncurl -I https://APP_NAME.ENV.yourdomain.com\n```\n\n## Backup and Recovery\n\n### Daily Backup Verification\n\n```bash\n#!/bin/bash\n# Daily backup verification - Save as /usr/local/bin/verify-daily-backup.sh\n\necho \"=== Daily Backup Verification - $(date) ===\"\n\n# 1. Check backup completion\nbackup_date=$(date +%Y%m%d)\nbackup_path=\"/mnt/qnap-backup/daily\"\n\nif [ -d \"$backup_path\" ]; then\n    today_backups=$(find \"$backup_path\" -name \"*$backup_date*\" -type f)\n    if [ -n \"$today_backups\" ]; then\n        echo \"✓ Today's backups found:\"\n        echo \"$today_backups\" | while read backup; do\n            size=$(du -h \"$backup\" | cut -f1)\n            echo \"  - $(basename \"$backup\") ($size)\"\n        done\n    else\n        echo \"✗ No backups found for today ($backup_date)\"\n        exit 1\n    fi\nelse\n    echo \"✗ Backup directory not accessible: $backup_path\"\n    exit 1\nfi\n\n# 2. Test backup integrity\necho \"\\nTesting backup integrity...\"\nlatest_backup=$(ls -t \"$backup_path\"/*\"$backup_date\"* 2>/dev/null | head -1)\nif [ -n \"$latest_backup\" ]; then\n    if tar -tzf \"$latest_backup\" >/dev/null 2>&1; then\n        echo \"✓ Backup integrity verified: $(basename \"$latest_backup\")\"\n    else\n        echo \"✗ Backup integrity check failed: $(basename \"$latest_backup\")\"\n        exit 1\n    fi\nfi\n\necho \"\\n✓ Daily backup verification completed successfully\"\n```\n\n### Weekly Backup Restoration Test\n\n```bash\n#!/bin/bash\n# Weekly backup restoration test - Save as /usr/local/bin/test-backup-restoration.sh\n\necho \"=== Weekly Backup Restoration Test - $(date) ===\"\n\n# 1. Create test environment\ntest_dir=\"/tmp/backup-restoration-test\"\nrm -rf \"$test_dir\"\nmkdir -p \"$test_dir\"\n\n# 2. Select backup to test\nbackup_path=\"/mnt/qnap-backup/weekly\"\nlatest_backup=$(ls -t \"$backup_path\"/*.tar.gz 2>/dev/null | head -1)\n\nif [ -z \"$latest_backup\" ]; then\n    echo \"✗ No weekly backup found for testing\"\n    exit 1\nfi\n\necho \"Testing restoration of: $(basename \"$latest_backup\")\"\n\n# 3. Extract backup\necho \"Extracting backup to test directory...\"\nif tar -xzf \"$latest_backup\" -C \"$test_dir\" 2>/dev/null; then\n    echo \"✓ Backup extraction successful\"\nelse\n    echo \"✗ Backup extraction failed\"\n    exit 1\nfi\n\n# 4. Verify extracted contents\necho \"\\nVerifying extracted contents...\"\nextracted_size=$(du -sh \"$test_dir\" | cut -f1)\nfile_count=$(find \"$test_dir\" -type f | wc -l)\necho \"Extracted size: $extracted_size\"\necho \"File count: $file_count\"\n\n# 5. Test key file integrity\necho \"\\nTesting key file integrity...\"\ntest_files=(\n    \"etc/docker/daemon.json\"\n    \"opt/traefik/traefik.yml\"\n    \"etc/systemd/system/dokploy.service\"\n)\n\nfor file in \"${test_files[@]}\"; do\n    if [ -f \"$test_dir/$file\" ]; then\n        echo \"✓ Key file present: $file\"\n    else\n        echo \"⚠ Key file missing: $file\"\n    fi\ndone\n\n# 6. Cleanup\nrm -rf \"$test_dir\"\n\necho \"\\n✓ Backup restoration test completed successfully\"\necho \"Backup verified: $(basename \"$latest_backup\")\"\n\n# 7. Log test results\necho \"$(date): Backup restoration test passed - $(basename \"$latest_backup\")\" >> /var/log/backup-test.log\n```\n\n## Performance Monitoring\n\n### Resource Usage Analysis\n\n```bash\n#!/bin/bash\n# Resource monitoring - Save as /usr/local/bin/monitor-resources.sh\n\necho \"=== Resource Usage Analysis - $(date) ===\"\n\n# 1. CPU Usage Analysis\necho \"1. CPU USAGE ANALYSIS\"\necho \"====================\"\necho \"Current load average:\"\nuptime\n\necho \"\\nCPU usage by process (top 10):\"\nps aux --sort=-%cpu | head -11\n\necho \"\\nCPU usage pattern (5 samples):\"\nfor i in {1..5}; do\n    cpu_usage=$(grep 'cpu ' /proc/stat | awk '{usage=($2+$4)*100/($2+$4+$5)} END {print usage}')\n    echo \"Sample $i: ${cpu_usage}%\"\n    sleep 2\ndone\n\n# 2. Memory Usage Analysis\necho \"\\n2. MEMORY USAGE ANALYSIS\"\necho \"========================\"\necho \"Current memory usage:\"\nfree -h\n\necho \"\\nMemory usage by process (top 10):\"\nps aux --sort=-%mem | head -11\n\n# 3. Disk Usage Analysis\necho \"\\n3. DISK USAGE ANALYSIS\"\necho \"======================\"\necho \"Filesystem usage:\"\ndf -h | grep -E \"(Filesystem|/dev/)\"\n\necho \"\\nLargest directories in /:\"\ndu -sh /* 2>/dev/null | sort -hr | head -10\n\n# 4. Network Usage Analysis\necho \"\\n4. NETWORK USAGE ANALYSIS\"\necho \"==========================\"\necho \"Network interface statistics:\"\ncat /proc/net/dev | head -3\ncat /proc/net/dev | grep -E \"(eth0|ens|enp)\"\n\necho \"\\nActive network connections:\"\nnetstat -tulpn | grep LISTEN | head -10\n\n# 5. Docker Resource Usage\necho \"\\n5. DOCKER RESOURCE USAGE\"\necho \"========================\"\nif command -v docker &> /dev/null; then\n    echo \"Docker system usage:\"\n    docker system df\n    \n    echo \"\\nContainer resource usage:\"\n    docker stats --no-stream --format \"table {{.Name}}\\t{{.CPUPerc}}\\t{{.MemUsage}}\\t{{.MemPerc}}\\t{{.NetIO}}\\t{{.BlockIO}}\"\nelse\n    echo \"Docker not available\"\nfi\n\n# 6. Generate Summary\necho \"\\n6. SUMMARY AND RECOMMENDATIONS\"\necho \"==============================\"\n\n# CPU recommendations\ncpu_load=$(uptime | awk -F'load average:' '{print $2}' | awk '{print $1}' | tr -d ',')\ncpu_cores=$(nproc)\nif (( $(echo \"$cpu_load > $cpu_cores\" | bc -l) )); then\n    echo \"⚠ HIGH CPU LOAD: Consider adding more CPU cores or optimizing workloads\"\nelse\n    echo \"✓ CPU load is normal\"\nfi\n\n# Memory recommendations\nmem_usage=$(free | awk 'NR==2{printf \"%.1f\", $3*100/$2 }')\nif (( $(echo \"$mem_usage > 80\" | bc -l) )); then\n    echo \"⚠ HIGH MEMORY USAGE: Consider adding more RAM or optimizing memory usage\"\nelse\n    echo \"✓ Memory usage is normal\"\nfi\n\n# Disk recommendations\ndisk_usage=$(df / | awk 'NR==2 {print $5}' | tr -d '%')\nif [ $disk_usage -gt 85 ]; then\n    echo \"⚠ HIGH DISK USAGE: Consider cleaning up or adding more storage\"\nelse\n    echo \"✓ Disk usage is normal\"\nfi\n\necho \"\\n=== Resource Analysis Complete ===\"\n```\n\n### Automated Monitoring Setup\n\n```bash\n#!/bin/bash\n# Setup automated monitoring - Save as /usr/local/bin/setup-monitoring.sh\n\necho \"=== Setting up Automated Monitoring ===\"\n\n# 1. Create monitoring directories\nsudo mkdir -p /var/log/monitoring\nsudo mkdir -p /usr/local/bin/monitoring\n\n# 2. Set up cron jobs for automated monitoring\necho \"Setting up cron jobs...\"\n\n# Daily health check\necho \"0 8 * * 1-5 /usr/local/bin/daily-health-check.sh | mail -s 'Daily Health Check' admin@yourdomain.com\" | crontab -\n\n# Weekly maintenance\necho \"0 2 * * 0 /usr/local/bin/weekly-maintenance.sh\" | crontab -\n\n# Monthly review\necho \"0 3 1 * * /usr/local/bin/monthly-review.sh | mail -s 'Monthly Review' admin@yourdomain.com\" | crontab -\n\n# Resource monitoring\necho \"*/15 * * * * /usr/local/bin/monitor-resources.sh >> /var/log/monitoring/resources.log 2>&1\" | crontab -\n\n# Backup verification\necho \"30 6 * * * /usr/local/bin/verify-daily-backup.sh | mail -s 'Backup Status' admin@yourdomain.com\" | crontab -\n\n# Weekly backup test\necho \"0 4 * * 0 /usr/local/bin/test-backup-restoration.sh | mail -s 'Backup Test Results' admin@yourdomain.com\" | crontab -\n\necho \"✓ Automated monitoring setup complete\"\necho \"\\nScheduled tasks:\"\ncrontab -l\n```\n\n## Escalation Procedures\n\n### Incident Response\n\n**Severity Levels**:\n\n```yaml\nCritical (P1):\n  - Complete infrastructure down\n  - Data loss or corruption\n  - Security breach\n  - Production services unavailable\n  Response Time: 15 minutes\n  Escalation: Immediate\n\nHigh (P2):\n  - Service degradation\n  - Non-critical service down\n  - Performance issues affecting users\n  Response Time: 1 hour\n  Escalation: 2 hours\n\nMedium (P3):\n  - Minor service issues\n  - Monitoring alerts\n  - Capacity warnings\n  Response Time: 4 hours\n  Escalation: 24 hours\n\nLow (P4):\n  - Informational alerts\n  - Scheduled maintenance\n  - Documentation updates\n  Response Time: 48 hours\n  Escalation: 1 week\n```\n\n**Contact Information**:\n\n```yaml\nPrimary Administrator:\n  Email: admin@yourdomain.com\n  Phone: +1-555-ADMIN\n  Available: 24/7 for P1 incidents\n\nSecondary Administrator:\n  Email: backup-admin@yourdomain.com\n  Phone: +1-555-BACKUP\n  Available: Business hours for P2+ incidents\n\nEscalation Contacts:\n  ISP Support: +1-555-ISP-HELP\n  Hardware Vendor: +1-555-HARDWARE\n  Domain Registrar: +1-555-DOMAIN\n```\n\n**Communication Channels**:\n\n```yaml\nFor Incidents:\n  Email: incidents@yourdomain.com\n  Slack: #incidents (if configured)\n  Status Page: status.yourdomain.com (if configured)\n\nFor Updates:\n  Email: admin@yourdomain.com\n  Documentation: /var/log/incidents/\n```\n\n## Continuous Improvement\n\n### Post-Incident Review Process\n\n**Within 24 hours of incident resolution**:\n\n1. **Incident Timeline Documentation**:\n   - When was the incident first detected?\n   - What was the root cause?\n   - What actions were taken?\n   - When was service restored?\n   - What was the impact?\n\n2. **Root Cause Analysis**:\n   - Why did the incident occur?\n   - What could have prevented it?\n   - Were monitoring and alerting adequate?\n   - Did procedures work as expected?\n\n3. **Action Items**:\n   - What immediate fixes are needed?\n   - What monitoring improvements are required?\n   - What process changes should be made?\n   - What training is needed?\n\n4. **Documentation Updates**:\n   - Update runbooks based on lessons learned\n   - Improve monitoring and alerting\n   - Update contact information\n   - Share knowledge with team\n\n### Monthly Process Review\n\n**First Friday of each month**:\n\n1. **Review previous month's incidents**\n2. **Analyze trends and patterns**\n3. **Update procedures based on lessons learned**\n4. **Review and update monitoring thresholds**\n5. **Plan improvements for next month**\n6. **Update documentation and training materials**\n\n---\n\n**Remember**: These runbooks are living documents that should be updated regularly based on experience and changing infrastructure needs. Always test procedures in the development environment before applying to production."